\begin{figure*}
\centering
\includegraphics[width=0.8\textwidth]{figures/syvolt_arch}
\caption{The architecture of the SyVOLT tool}
\label{fig:arch}
\end{figure*}

One principle of the Modelling, Design, and Simulation Lab is that all tools and
processes should be explicitly modelled at an appropriate abstraction level.
This practice goes in the direction of ensuring that essential
complexity is the main object of software development and that accidental
complexity is mitigated as much as possible.

SyVOLT's codebase has been developed by applying these principles. We have used
available model-driven development technology as much as possible. In
particular, we have made it such that representations of DSLTrans transformations
and SyVOLT contracts manipulated by the proof engine are models, as well as the
symbolic executions produced for a given DSLTrans model transformation (called
\emph{path conditions}). Additionally, given the operations required to build a
contract proof are model manipulations, they are also encoded as model
transformations~\cite{LucioVang}.\\

The following model-driven development tools have been used either as part of
SyVOLT's codebase, or for SyVOLT's development:
\begin{itemize}
  \item \textbf{AToM$^3$}~\cite{}: AToM$^3$ is a meta-editor for model-driven
  development. It has been developed at the MSDL and is used for constructing,
  models and metamodels, and for automatically synthesising modeling
  environments.
  AToM$^3$ has been extensively used to build, edit and visualize models and
  contracts during the initial stages of the construction of SyVOLT.\\
  \item \textbf{Himesis}~\cite{}: Himesis is a typed graph representation
  format, built upon the open-source igraph~\cite{} library. Himesis has been
  developed at the MSDL and is used to represent all models manipulated by SyVOLT when a proof is being built.
  Himesis is also used to represent the metamodels that allow building the
  models used inside SyVOLT. Note that, while metamodels during the construction
  of SyVOLT to provide exemplar data for the algorithm, in the finished
  SyVOLT all models are automatically generated and metamodels only exist
  implicitly.\\
  \item \textbf{T-Core}~\cite{}: T-Core is a collection of model transformation
  primitives developed at the MSDL, allowing fine-grained manipulation of
  models. It was initially built as a means to rapidly build
  high-level model transformation languages. T-Core has been used to
  successfully deconstruct and reconstruct several mainstream model transformation
  languages. The main operations of T-Core are model \emph{matching}, model
  \emph{rewriting} and \emph{iterating} through a set of match sites in a model.
  The level of control in model manipulation together with T-Core's speed and
  scalability when treating large models suited well our needs when implementing
  the property proof algorithm described in~\cite{Lucio2014}. Note that because
  T-Core is also an explicitly modeled model transformation language, a T-Core
  model transformation rule is also a Himesis model.\\
  \item \textbf{EMF} (Eclipse Modelling Framework)~\cite{}: SyVOLT makes use of
  EMF's E-Core format for the XMI~\footnote{\url{http://www.omg.org/spec/XMI/}} representation of DSLTrans transformations
  and SyVOLT's contracts within the Eclipse editors. Note that EMF is only used
  in the Eclipse front-end, and that models in those formats are converted into
  Himesis such that the contract prover engine can compute the proofs.\\
  \item \textbf{EGL} (Epsilon Generation Language)~\cite{}: Converting E-Core
  models into Himesis models is achieved using EGL, a language from the Epsilon family. This
  model-to-text transformation language is used to parse the E-Core models of
  a DSLTrans model transformation and of the contracts to be proved, in order
  to produce a number of Python files containing the models and model
  transformation rules in the Himesis format that are needed to automatically
  perform the required proofs.

\end{itemize}

Elements of the
architecture that could not be built using model driven tools (for lack of
technological availability) have been developed using model-driven principles.



Figure~\ref{fig:arch} shows the architecture of the SyVOLT tool. We will now
briefly visit each component in turn, mentioning the main technologies and
languages employed.


In particular, each artifact and transformation in the contract prover is
explicitly modelled. EXPAND

Present:
\begin{itemize}
  \item Technology used: introduce orthogonal technologies used in all
  static components
  \item Static components
  \item Flow
\end{itemize}

The contract prover makes heavy use of T-Core [CITE], which is a framework of
transformation primitives. For example, the T-Core Matcher and Rewriter is
scheduled by Python in order to perform rewriting on a graph in an efficient
manner.


\subsection{Eclipse Frontend (1)}

The SyVolt contract editor is realized by a set of Eclipse plugins.
The runtime architecture of this editor is the typical architecture of a Graphical Modeling Framework (GMF) \footnote{\url{http://www.eclipse.org/modeling/gmp/}} editor. 
What is important is how this editor was developed.

As mentioned in Section~\ref{sec:mdd_gui}, we used Eugenia[CITE] to quickly develop the SyVolt contract editor shown in Figure~\ref{fig:eclipse_frontend}.

Eugenia consists of a set of annotations that are attached to the metamodel of
SyVolt contracts. An annotation can, for instance, specify that an atomic contract will be drawn as a rounded rectangle, with a specific color and a label that is equal to the name attribute of the contract.
The annotations are not very expressive but they contain the essential information to generate a set of GMF models that, ultimately, describe a basic usable graphical editor. 

Each generated GMF model is concerned with one aspect of the editor and can be further customized to our needs. GMF models are much more expressive than the Eugenia annotations.
For instance, the generated GMF tooling model prescribes the kind of tools that
will be available in the toolbox (shown in the right of
Figure~\ref{fig:eclipse_frontend}), their icons, labels, etc\ldots

From the set of GMF models, a set of eclipse plugins are synthesized.
These make up SyVolt graphical editor\footnote{A fixed structure textual editor is also provided but this editor lacks several usability improvements and, hence, is not appropriate to model SyVolt contracts.}.


\subsection{Generating Artifacts (2) \cgg{I propose new name for this: Himesis Graph Generation (2)}}

The SyVolt contract prover uses Himesis~\cite{Provost2006} internally to represent all models for several reasons: independence, efficiency and tool support.
Independence is ensured because Himesis is very expressive and also very simple, which means it will not change for the foreseeable future. 
In \cite{Syriani2010b}, it is reported empirically that Himesis is a good format to perform the typical graph manipulation operations and it is seamlessly supported by T-Core~\cite{Syriani2010a}.

To translate SyVolt contracts and DSLTrans transformations into the equivalent Himesis representations we used the Epsilon Generation Language (EGL~\cite{Rose2008}).
Besides easy integration with Eclipse and native support of the expressive Epsilon Object Language (EOL~\cite{Kolovos}), EGL also provides tasks for the Ant~\footnote{\url{http://ant.apache.org}} build tool, which was used to orchestrate the multiple tools in the proving process (see Section~\ref{sec:push_button_proofs}).

We used two EGL Transformations: one to generate the Himesis representation of a DSLTRans transformation and one to generate the Himesis representation of the SyVolt contracts. The original DSLTrans transformation is manipulated using the DSLTrans editor and is serialized in XMI format. Similarly, SyVolt contracts are manipulated with the SyVolt graphical editor and serialized in XMI format.

As opposed to the XMI format which declaratively represents the graph, the Himesis representation of a graph is given by Python code referencing the Himesis library. When this code is executed it loads the Himesis graph to memory.

Since Himesis is a textual format, identifiers are necessary to correctly describe the associations between graph nodes. The EGL transformations make sure these are correctly generated.


\subsection{PyRamify (3)}

PyRamify is a Python script that takes as input Himesis graphs representing the rules in the transformation. Then, through the RAMification procedure [CITE RAM], matchers for each rule are produced. These matchers will then match over the rules, which allows the contract prover to determine how rules might execute over an input model. Rewriters are also produced with traceability information, which will properly apply the right-hand side of a rule when it matches.

Currently, PyRamify is implemented as a Python script, as we were unable to implement automatic creation of higher-order artifacts in another modelling tool. This is a limitation that we hope will be addressed in the future, as the mix of different abstraction level led to a number of technical difficulties.

\subsection{Path Condition Generation (4)}

Once the required artifacts have been produced, the prover moves onto the path condition generation step.  Each
path condition will represent a set of concrete executions
of the transformation, where each concrete execution is an
input/ouput pair.

Our proving algorithm begins by generating one empty
path condition, representing the case where no rules in the
transformation have executed. Then, each rule in each layer
is examined, and its graph is combined with the graph of
each path condition generated thus far. As each layer in the
transformation is considered, the set of path conditions will
grow to represent all allowed combinations of rules. As rules
may depend on each other because of backward links, such
dependencies are verified by the path condition generation
algorithm in order to exclude impossible rule combinations.
The final set of path conditions produced by the algorithm
will then abstract the infinite set of all concrete transformation
executions. This is further described in~\cite{Lucio2014}, along with a
formal discussion of the validity and completeness of this
work.

\subsection{Contract Proof (5)}

Once the path conditions are generated, we can then begin the proof for each contract.

Pre- / post- condition contracts form an implication, which
needs to be checked for each path condition generated for
the transformation by the above algorithm. In broad terms,
a contract holds on a path condition if either the contractâ€™s
pre-condition cannot be isomorphically found in the path
condition, or the contracts pre-condition together with its post-
condition can be found in the path condition. The contract
does not hold on the path condition if its pre-condition can
be isomorphically found in the path condition but its post-
condition cannot. This produces a counter-example for the contract, which we then present to the user. Finally, a contract holds for a transformation if it holds for all of its generated path conditions. These results
are formally described in~\cite{Lucio2014}.

A contract holds in the transformation if, for all input models where the contract's pre-condition is found, the contract's post-condition is also found in the corresponding output model (with optional traceability constraints between the elements of the input and output models). Otherwise, the contract does not hold.


